#!/bin/sh
# SPDX-License-Identifier: GPL-2.0
# Copyright (C) 2025-present ROCKNIX (https://github.com/ROCKNIX)

. /etc/profile

### Enable logging
case $(get_setting system.loglevel) in
verbose)
  DEBUG=true
  ;;
*)
  DEBUG=false
  ;;
esac

SUSPEND_MODE="$(get_setting system.suspendmode)"

# Only do something when suspend mode is off
if [ "${SUSPEND_MODE}" != "off" ]; then
  ${DEBUG} && log $0 "Suspend enabled, exiting"
  exit 0
fi

# Only do something when HDMI is disconnected
HDMI_STATUS=$(cat /sys/class/drm/card*/card*-HDMI-A-[0-9]/status)

if [[ "${HDMI_STATUS}" = "connected" ]]; then
  ${DEBUG} && log $0 "HDMI connected, exiting"
  exit 0
fi

# Only do something when charger is disconnected
CHARGE_STATUS=$(cat /sys/class/power_supply/battery/status)

if [[ "${CHARGE_STATUS}" = "Charging" ]]; then
  ${DEBUG} && log $0 "Charger connected, exiting"
  exit 0
fi

# If a game is not running, by default shutdown immediately
SHUTDOWN_DELAY="$(get_setting system.shutdown_delay)"
if [ "${SHUTDOWN_DELAY}" = "" ]; then
    SHUTDOWN_DELAY=0
fi

# If a game is running, by default delay the shutdown for 5 minutes
SHUTDOWN_DELAY_RUNNING_GAME="$(get_setting system.shutdown_delay_running_game)"
if [ "${SHUTDOWN_DELAY_RUNNING_GAME}" = "" ]; then
    SHUTDOWN_DELAY_RUNNING_GAME=900
fi

# flag file
PID=$$
FLAG_FILE_PATTERN="/var/run/lid-close-shutdown-delay.flag"
FLAG_FILE="${FLAG_FILE_PATTERN}.${PID}"

# Process to kill
TO_KILL="rocknix-lid"

# Action = open / close
ACTION=$1

check_es_running_game() {
  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:1234/runningGame")
  ${DEBUG} && log $0 "ES runningGame HTTP_STATUS - ${HTTP_STATUS}"
  test $? != 0 && return 1 # call failed, assume no game running
  test "${HTTP_STATUS}" = 201 && return 1 # 201 when no game running
  test "${HTTP_STATUS}" = 200 && return 0 # 200 when game running
}

do_lid_close_actions() {
  # Turn off display
  if echo "${UI_SERVICE}" | grep "sway"; then
    ${DEBUG} && log $0 "Display power off"
    swaymsg "output * power off"
  fi

  # Mute audio
  ${DEBUG} && log $0 "Mute audio"
  wpctl set-mute @DEFAULT_AUDIO_SINK@ 1

  # CPU core parking
  ${DEBUG} && log $0 "CPU core parking"
  for x in /sys/devices/system/cpu/cpu*/online; do
    if [ ! $(echo "${x}" | grep "cpu0") ]; then
      echo 0 > "${x}"
    fi
  done
}

do_lid_open_actions() {
  # Turn on display
  if echo "${UI_SERVICE}" | grep "sway"; then
    ${DEBUG} && log $0 "Display power on"
    swaymsg "output * power on"
  fi

  # Unmute audio
  ${DEBUG} && log $0 "Unmute audio"
  wpctl set-mute @DEFAULT_AUDIO_SINK@ 0

  # Undo CPU core parking
  ${DEBUG} && log $0 "Undo CPU core parking"
  for x in /sys/devices/system/cpu/cpu*/online; do
    echo 1 > "${x}"
  done
}

do_shutdown() {
  # Unmute audio - otherwise wireplumber will keep it muted on next boot
  ${DEBUG} && log $0 "Unmute audio"
  wpctl set-mute @DEFAULT_AUDIO_SINK@ 0

  # Check whether a game is running
  check_es_running_game
  RUNNING_GAME=$?

  if [[ $RUNNING_GAME -eq 0 ]]; then
    # ES shutdown API won't work if a game is running
    ${DEBUG} && log $0 "Shutting down now"
    shutdown now
  else
    # Use ES shutdown API so metadata is saved
    ${DEBUG} && log $0 "Shutting down via ES API"
    curl "http://localhost:1234/shutdown"
  fi
}

if [ "${ACTION}" = "close" ]; then
  # Lid close event - create flag file
  ${DEBUG} && log $0 "Lid close - creating ${FLAG_FILE}"
  touch "${FLAG_FILE}"

  # Wait for the desired shutdown delay
  check_es_running_game
  RUNNING_GAME=$?

  if [[ $RUNNING_GAME -eq 0 ]]; then
    DELAY=${SHUTDOWN_DELAY_RUNNING_GAME}
    ${DEBUG} && log $0 "Game running"
  else
    ${DEBUG} && log $0 "No game running"
    DELAY=${SHUTDOWN_DELAY}
  fi

  # Actions on lid close, only if there is a timed delay
  if [[ "${DELAY}" -gt 0 ]]; then
    do_lid_close_actions
  fi

  sleep ${DELAY}

  # Delay has completed - check whether the flag file is still present
  if [ -f "${FLAG_FILE}" ]; then
    ${DEBUG} && log $0 "Delay expired, flag file found, shutting down"
    # Do shutdown
    do_shutdown
  else
    ${DEBUG} && log $0 "Delay expired, flag file not found"
  fi

  exit 0
else
  # Lid open event - remove the flag file and kill processes
  ${DEBUG} && log $0 "Lid open - removing ${FLAG_FILE_PATTERN}.*"
  rm "${FLAG_FILE_PATTERN}".*

  # Do lid open actions
  do_lid_open_actions

  ${DEBUG} && log $0 "Lid open - killing ${TO_KILL} processes"
  killall ${TO_KILL}

  exit 0
fi
